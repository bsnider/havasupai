import{dR as k,cJ as G,cZ as O,dS as $,d0 as B}from"./index-DXVHLZmj.js";async function R(o,n,r,s){var F,I;const c=new Array(n.length),d=new Map,u=new Map,h=k(o.fieldsIndex,r.outFields),j=(s==null?void 0:s.hasRequiredFields)??O;for(let e=0;e<n.length;e++){const t=n[e];if(t.isAggregate){c[e]=t;continue}let a=!1;if(s!=null&&s.getPopupTemplate){const l=((F=t.origin)==null?void 0:F.layer)??t.sourceLayer??t.layer,i=s.getPopupTemplate(l);if(i==null)continue;const f=await M(i);G(s),a=f&&f.arcadeUtils.hasGeometryOperations(i)}if(a||!j(t,h)){const l=t.getObjectId();if(l!=null){d.set(l,{graphic:t,index:e});continue}const i=t.getGlobalId();if(i!=null){u.set(i,{graphic:t,index:e});continue}}c[e]=t}if(!o.queryFeatures||d.size===0&&u.size===0)return c.filter(Boolean);const g=[],m=(e,t)=>{t&&(e.outFields??(e.outFields=[]),e.outFields.includes(t)||e.outFields.push(t))};if(d.size>0){const e=r.clone();m(e,o.objectIdField),"uniqueIdFields"in o&&((I=o.uniqueIdFields)!=null&&I.length)&&(e.outFields??(e.outFields=[]),e.outFields.push(...o.uniqueIdFields)),e.objectIds=Array.from(d.keys()),g.push({type:"object-id",query:e,map:d})}const y="globalIdField"in o?o.globalIdField:null;if(y!=null&&u.size>0){const e=r.clone();m(e,y);const t=Array.from(u.keys());e.where=$(r.where,`${y} IN (${t.map((a=>`'${a}'`)).join(",")})`),g.push({type:"global-id",query:e,map:u})}const w=(s==null?void 0:s.updateSourceAttributes)??!1;for(const{type:e,query:t,map:a}of g)try{const l=await o.queryFeatures(t,s);for(const i of l.features){const f=e==="object-id"?i.getObjectId():i.getGlobalId();if(f==null)continue;const q=a.get(f);if(!q)continue;const{graphic:p,index:x}=q;if(w&&i.attributes){p.attributes??(p.attributes={});for(const b of h)b in i.attributes&&(p.attributes[b]=i.attributes[b])}const{geometry:A,origin:z}=p;i.geometry||(i.geometry=A),i.origin=z,c[x]=i}}catch{}return c.filter(Boolean)}async function M(o){var n;if((n=o.expressionInfos)!=null&&n.length||Array.isArray(o.content)&&o.content.some((r=>r.type==="expression")))return B()}export{M as r,R as s};
