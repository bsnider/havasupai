import{ca as C,bH as tt,O as et,d$ as G,bZ as nt,z as rt,dz as ot}from"./index-Ds3x37R4.js";const O=()=>tt.getLogger("esri.views.2d.engine.flow.dataUtils"),lt=10;async function mt(i,r,a,h){const l=performance.now(),u=at(r,a),f=performance.now(),e=st(r,u,a.width,a.height),n=performance.now(),t=ft(e),o=performance.now(),d=i==="Streamlines"?ut(t,lt):ht(t),g=performance.now();return C("esri-2d-profiler")&&(O().info("I.1","_createFlowFieldFromData (ms)",Math.round(f-l)),O().info("I.2","_getStreamlines (ms)",Math.round(n-f)),O().info("I.3","createAnimatedLinesData (ms)",Math.round(o-n)),O().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(g-o)),O().info("I.5","createFlowMesh (ms)",Math.round(g-l)),O().info("I.6","Mesh size (bytes)",d.vertexData.buffer.byteLength+d.indexData.buffer.byteLength)),await Promise.resolve(),et(h),d}function at(i,r){const a=ct(r.data,r.width,r.height,i.smoothing);return i.interpolate?(h,l)=>{const u=Math.floor(h),f=Math.floor(l);if(u<0||u>=r.width)return[0,0];if(f<0||f>=r.height)return[0,0];const e=h-u,n=l-f,t=u,o=f,d=u<r.width-1?u+1:u,g=f<r.height-1?f+1:f,m=a[2*(o*r.width+t)],p=a[2*(o*r.width+d)],v=a[2*(g*r.width+t)],D=a[2*(g*r.width+d)],I=a[2*(o*r.width+t)+1],y=a[2*(o*r.width+d)+1];return[(m*(1-n)+v*n)*(1-e)+(p*(1-n)+D*n)*e,(I*(1-n)+a[2*(g*r.width+t)+1]*n)*(1-e)+(y*(1-n)+a[2*(g*r.width+d)+1]*n)*e]}:(h,l)=>{const u=Math.round(h),f=Math.round(l);return u<0||u>=r.width||f<0||f>=r.height?[0,0]:[a[2*(f*r.width+u)],a[2*(f*r.width+u)+1]]}}function it(i,r,a,h,l,u,f,e,n){const t=[];let o=a,d=h,g=0,[m,p]=r(o,d);m*=i.velocityScale,p*=i.velocityScale;const v=Math.sqrt(m*m+p*p);let D,I;t.push({x:o,y:d,t:g,speed:v});for(let y=0;y<i.verticesPerLine;y++){let[x,w]=r(o,d);x*=i.velocityScale,w*=i.velocityScale;const s=Math.sqrt(x*x+w*w);if(s<i.minSpeedThreshold)return t;const c=x/s,P=w/s;if(o+=c*i.segmentLength,d+=P*i.segmentLength,g+=i.segmentLength/s,Math.acos(c*D+P*I)>i.maxTurnAngle)return t;if(i.collisions){const M=Math.round(o*n),S=Math.round(d*n);if(M<0||M>f-1||S<0||S>e-1)return t;const R=u[S*f+M];if(R!==-1&&R!==l)return t;u[S*f+M]=l}t.push({x:o,y:d,t:g,speed:s}),D=c,I=P}return t}function st(i,r,a,h){const l=[],u=new G,f=1/Math.max(i.lineCollisionWidth,1),e=Math.round(a*f),n=Math.round(h*f),t=new Int32Array(e*n);for(let d=0;d<t.length;d++)t[d]=-1;const o=[];for(let d=0;d<h;d+=i.lineSpacing)for(let g=0;g<a;g+=i.lineSpacing)o.push({x:g,y:d,sort:u.getFloat()});o.sort(((d,g)=>d.sort-g.sort));for(const{x:d,y:g}of o)if(u.getFloat()<i.density){const m=it(i,r,d,g,l.length,t,e,n,f);if(m.length<2)continue;l.push(m)}return l}function ct(i,r,a,h){if(h===0)return i;const l=Math.round(3*h),u=new Array(2*l+1);let f=0;for(let t=-l;t<=l;t++){const o=Math.exp(-t*t/(h*h));u[t+l]=o,f+=o}for(let t=-l;t<=l;t++)u[t+l]/=f;const e=new Float32Array(i.length);for(let t=0;t<a;t++)for(let o=0;o<r;o++){let d=0,g=0;for(let m=-l;m<=l;m++){if(o+m<0||o+m>=r)continue;const p=u[m+l];d+=p*i[2*(t*r+(o+m))],g+=p*i[2*(t*r+(o+m))+1]}e[2*(t*r+o)]=d,e[2*(t*r+o)+1]=g}const n=new Float32Array(i.length);for(let t=0;t<r;t++)for(let o=0;o<a;o++){let d=0,g=0;for(let m=-l;m<=l;m++){if(o+m<0||o+m>=a)continue;const p=u[m+l];d+=p*e[2*((o+m)*r+t)],g+=p*e[2*((o+m)*r+t)+1]}n[2*(o*r+t)]=d,n[2*(o*r+t)+1]=g}return n}function ft(i,r){const a=new G,h=i.reduce(((n,t)=>n+t.length),0),l=new Float32Array(4*h),u=new Array(i.length);let f=0,e=0;for(const n of i){const t=f;for(const o of n)l[4*f]=o.x,l[4*f+1]=o.y,l[4*f+2]=o.t,l[4*f+3]=o.speed,f++;u[e++]={startVertex:t,numberOfVertices:n.length,totalTime:n[n.length-1].t,timeSeed:a.getFloat()}}return{lineVertices:l,lineDescriptors:u}}function ut(i,r){const{lineVertices:h,lineDescriptors:l}=i;let u=0,f=0;for(const m of l)u+=2*m.numberOfVertices,f+=6*(m.numberOfVertices-1);const e=new Float32Array(u*9),n=new Uint32Array(f);let t=0,o=0;function d(){n[o++]=t-2,n[o++]=t,n[o++]=t-1,n[o++]=t,n[o++]=t+1,n[o++]=t-1}function g(m,p,v,D,I,y,x,w){const s=t*9;let c=0;e[s+c++]=m,e[s+c++]=p,e[s+c++]=1,e[s+c++]=v,e[s+c++]=y,e[s+c++]=x,e[s+c++]=D/2,e[s+c++]=I/2,e[s+c++]=w,t++,e[s+c++]=m,e[s+c++]=p,e[s+c++]=-1,e[s+c++]=v,e[s+c++]=y,e[s+c++]=x,e[s+c++]=-D/2,e[s+c++]=-I/2,e[s+c++]=w,t++}for(const m of l){const{totalTime:p,timeSeed:v}=m;let D=null,I=null,y=null,x=null,w=null,s=null;for(let c=0;c<m.numberOfVertices;c++){const P=h[4*(m.startVertex+c)],M=h[4*(m.startVertex+c)+1],S=h[4*(m.startVertex+c)+2],R=h[4*(m.startVertex+c)+3];let T=null,U=null,_=null,N=null;if(c>0){T=P-D,U=M-I;const V=Math.sqrt(T*T+U*U);if(T/=V,U/=V,c>1){let A=T+w,F=U+s;const b=Math.sqrt(A*A+F*F);A/=b,F/=b;const z=Math.min(1/(A*T+F*U),r);A*=z,F*=z,_=-F,N=A}else _=-U,N=T;_!==null&&N!==null&&(g(D,I,y,_,N,p,v,R),d())}D=P,I=M,y=S,w=T,s=U,x=R}g(D,I,y,-s,w,p,v,x)}return{vertexData:e,indexData:n}}function ht(i){const{lineVertices:l,lineDescriptors:u}=i;let f=0,e=0;for(const V of u){const A=V.numberOfVertices-1;f+=4*A*2,e+=6*A*2}const n=new Float32Array(f*16),t=new Uint32Array(e);let o,d,g,m,p,v,D,I,y,x,w,s,c,P,M=0,S=0;function R(){t[S++]=M-8,t[S++]=M-7,t[S++]=M-6,t[S++]=M-7,t[S++]=M-5,t[S++]=M-6,t[S++]=M-4,t[S++]=M-3,t[S++]=M-2,t[S++]=M-3,t[S++]=M-1,t[S++]=M-2}function T(V,A,F,b,z,j,q,B,E,H,J,K,Q,X){const k=M*16;let L=0;for(const Y of[1,2])for(const $ of[1,2,3,4])n[k+L++]=V,n[k+L++]=A,n[k+L++]=F,n[k+L++]=b,n[k+L++]=q,n[k+L++]=B,n[k+L++]=E,n[k+L++]=H,n[k+L++]=Y,n[k+L++]=$,n[k+L++]=Q,n[k+L++]=X,n[k+L++]=z/2,n[k+L++]=j/2,n[k+L++]=J/2,n[k+L++]=K/2,M++}function U(V,A){let F=y+w,b=x+s;const z=Math.sqrt(F*F+b*b);F/=z,b/=z;const j=y*F+x*b;F/=j,b/=j;let q=w+c,B=s+P;const E=Math.sqrt(q*q+B*B);q/=E,B/=E;const H=w*q+s*B;q/=H,B/=H,T(o,d,g,m,-b,F,p,v,D,I,-B,q,V,A),R()}function _(V,A,F,b,z,j){if(y=w,x=s,w=c,s=P,y==null&&x==null&&(y=w,x=s),p!=null&&v!=null){c=V-p,P=A-v;const q=Math.sqrt(c*c+P*P);c/=q,P/=q}y!=null&&x!=null&&U(z,j),o=p,d=v,g=D,m=I,p=V,v=A,D=F,I=b}function N(V,A){y=w,x=s,w=c,s=P,y==null&&x==null&&(y=w,x=s),y!=null&&x!=null&&U(V,A)}for(const V of u){o=null,d=null,g=null,m=null,p=null,v=null,D=null,I=null,y=null,x=null,w=null,s=null,c=null,P=null;const{totalTime:A,timeSeed:F}=V;for(let b=0;b<V.numberOfVertices;b++)_(l[4*(V.startVertex+b)],l[4*(V.startVertex+b)+1],l[4*(V.startVertex+b)+2],l[4*(V.startVertex+b)+3],A,F);N(A,F)}return{vertexData:n,indexData:t}}function W(i,r){const a=r.pixels,{width:h,height:l}=r,u=new Float32Array(h*l*2),f=r.mask||new Uint8Array(h*l*2);if(r.mask||f.fill(255),i==="vector-uv")for(let e=0;e<h*l;e++)u[2*e]=a[0][e],u[2*e+1]=-a[1][e];else if(i==="vector-magdir")for(let e=0;e<h*l;e++){const n=a[0][e],t=ot(a[1][e]),o=Math.cos(t-Math.PI/2),d=Math.sin(t-Math.PI/2);u[2*e]=o*n,u[2*e+1]=d*n}return{data:u,mask:f,width:h,height:l}}async function wt(i,r,a,h,l,u){const f=performance.now(),e=nt(r.spatialReference);if(!e){const w=await Z(i,r,a,h,l,u);return C("esri-2d-profiler")&&O().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-f)),C("esri-2d-profiler")&&O().info("I.9","Number of parts",1),w}const[n,t]=e.valid,o=t-n,d=Math.ceil(r.width/o),g=r.width/d,m=Math.round(a/d);let p=r.xmin;const v=[],D=performance.now();for(let w=0;w<d;w++){const s=new rt({xmin:p,xmax:p+g,ymin:r.ymin,ymax:r.ymax,spatialReference:r.spatialReference});v.push(Z(i,s,m,h,l,u)),p+=g}const I=await Promise.all(v);C("esri-2d-profiler")&&O().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-D)),C("esri-2d-profiler")&&O().info("I.9","Number of parts",I.length);const y={data:new Float32Array(a*h*2),mask:new Uint8Array(a*h),width:a,height:h};let x=0;for(const w of I){for(let s=0;s<w.height;s++)for(let c=0;c<w.width;c++)x+c>=a||(y.data[2*(s*a+x+c)]=w.data[2*(s*w.width+c)],y.data[2*(s*a+x+c)+1]=w.data[2*(s*w.width+c)+1],y.mask[s*a+x+c]=w.mask[s*w.width+c]);x+=w.width}return C("esri-2d-profiler")&&O().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-f)),y}async function Z(i,r,a,h,l,u){var n;const f={requestProjectedLocalDirections:!0,signal:u};if(l!=null&&(f.timeExtent=l),i.type==="imagery"){await i.load({signal:u});const t=await i.internalFetchImage(r,a,h,f);return((n=t==null?void 0:t.pixelData)==null?void 0:n.pixelBlock)==null?{data:new Float32Array(a*h*2),mask:new Uint8Array(a*h),width:a,height:h}:W(i.rasterInfo.dataType,t.pixelData.pixelBlock)}await i.load({signal:u});const e=await i.fetchPixels(r,a,h,f);return(e==null?void 0:e.pixelBlock)==null?{data:new Float32Array(a*h*2),mask:new Uint8Array(a*h),width:a,height:h}:W(i.serviceRasterInfo.dataType,e.pixelBlock)}export{at as c,wt as g,mt as s,st as u};
