import{bH as M,bI as b,bJ as C,bK as d,bL as I,bM as x,bN as O,bO as k,bP as S,bQ as h,bR as N,ab as P}from"./index-DXVHLZmj.js";import T from"./callExpressionWithFeature-D7xNhsQt.js";const g=y=>{if(!y)return[0,0,0,0];const{r:e,g:r,b:s,a:i}=y;return[e,r,s,255*i]},a=class a{static findApplicableOverrides(e,r,s){if(e&&r){if(e.primitiveName){let i=!1;for(const t of s)if(t.primitiveName===e.primitiveName){i=!0;break}if(!i)for(const t of r)t.primitiveName===e.primitiveName&&s.push(t)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const i of e.effects)a.findApplicableOverrides(i,r,s);if(e.symbolLayers)for(const i of e.symbolLayers)a.findApplicableOverrides(i,r,s);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const i of e.effects)a.findApplicableOverrides(i,r,s);if(e.markerPlacement&&a.findApplicableOverrides(e.markerPlacement,r,s),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const i of e.markerGraphics)a.findApplicableOverrides(i,r,s),a.findApplicableOverrides(i.symbol,r,s)}else e.type==="CIMCharacterMarker"?a.findApplicableOverrides(e.symbol,r,s):e.type==="CIMHatchFill"?a.findApplicableOverrides(e.lineSymbol,r,s):e.type==="CIMPictureMarker"&&a.findApplicableOverrides(e.animatedSymbolProperties,r,s)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&M(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const s=b(e),i=e.primitiveName,t=[];for(const o of r)o.primitiveName===i&&t.push(b(o));return{type:"cim-effect-param",effect:s,overrides:C(t)}}static async resolveSymbolOverrides(e,r,s,i,t,o,c){if(!(e!=null&&e.symbol))return null;let{symbol:l,primitiveOverrides:n}=e;const m=!!n;if(!m&&!i)return l;l=d(l),n=d(n);let v=!0;if(r||(r={attributes:{}},v=!1),m){if(v||(n=n.filter((f=>{var p;return!((p=f.valueExpressionInfo)!=null&&p.expression.includes("$feature"))}))),c||(n=n.filter((f=>{var p;return!((p=f.valueExpressionInfo)!=null&&p.expression.includes("$view"))}))),n.length>0){const f=I(r.attributes),p={spatialReference:s,fields:f,geometryType:t};await a.createRenderExpressions(n,p),a.evaluateOverrides(n,r,t??"esriGeometryPoint",o,c,new x(f))}a.applyOverrides(l,n)}return i&&a.applyDictionaryTextOverrides(l,r,i,null),l}static async createRenderExpressions(e,r){const s=[];for(const i of e){const t=i.valueExpressionInfo;if(!t||a._expressionToRenderExpression.has(t.expression))continue;const o=O(t.expression,r.spatialReference);s.push(o),o.then((c=>a._expressionToRenderExpression.set(t.expression,c)))}s.length>0&&await Promise.all(s)}static evaluateOverrides(e,r,s,i,t,o){const c={$view:{scale:t==null?void 0:t.scale}};for(const l of e){l.value&&typeof l.value=="object"&&k(l.value)&&(l.propertyName==="Color"||l.propertyName==="StrokeColor")&&(l.value=g(l.value));const n=l.valueExpressionInfo;if(!n)continue;const m=a._expressionToRenderExpression.get(n.expression);m&&(l.value=T(m,r,c,s,o,i))}}static applyDictionaryTextOverrides(e,r,s,i,t="Normal"){if(e!=null&&e.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const o=e.symbolLayers;if(!o)return;for(const c of o)c&&c.type==="CIMVectorMarker"&&a.applyDictionaryTextOverrides(c,r,s,i,e.type==="CIMTextSymbol"?e.textCase:t)}break;case"CIMVectorMarker":{const o=e.markerGraphics;if(!o)return;for(const c of o)c&&a.applyDictionaryTextOverrides(c,r,s,i)}break;case"CIMMarkerGraphic":{const o=e.textString;if(o&&o.includes("[")){const c=S(o,s);e.textString=h(r,c,i,t)}}}}static applyOverrides(e,r,s,i){if(e.primitiveName){for(const t of r)if(t.primitiveName===e.primitiveName){const o=N(t.propertyName);if(i&&i.push({cim:e,nocapPropertyName:o,value:e[o]}),s){let c=!1;for(const l of s)l.primitiveName===e.primitiveName&&(c=!0);c||s.push(t)}t.value!=null&&(e[o]=t.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const t of e.effects)a.applyOverrides(t,r,s,i);if(e.symbolLayers)for(const t of e.symbolLayers)a.applyOverrides(t,r,s,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const t of e.effects)a.applyOverrides(t,r,s,i);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const t of e.markerGraphics)a.applyOverrides(t,r,s,i),a.applyOverrides(t.symbol,r,s,i)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const s of e)s.value!==void 0&&(r+=`${s.primitiveName}${s.propertyName}${JSON.stringify(s.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map((s=>Number(s)));if(e==="Color"){const s=new P(r).toRgba();return s[3]*=255,s}return r}};a._expressionToRenderExpression=new Map;let u=a;export{u as OverrideHelper};
